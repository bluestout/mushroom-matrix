<style>
  recharge-subscription-widget {
    max-width: 100% !important;
  }
</style>

<script>
  console.log('Recharge widget customization........');
  document.addEventListener('DOMContentLoaded', function () {
    // Initialize the global flag
    window.isRechargeWidgetLoaded = false;

    function waitForRechargeWidget() {
      const widgetSelector = 'recharge-subscription-widget';
      console.log('Waiting for Recharge Subscription Widget to load...');

      // Use setInterval to check for the widget every 300ms
      const intervalId = setInterval(() => {
        const widget = document.querySelector(widgetSelector);
        if (widget && widget.shadowRoot) {
          const isLoaded = widget.shadowRoot.querySelector('.rc-selection__root'); // Replace with actual class inside
          if (isLoaded) {
            console.log('Recharge Subscription Widget is fully rendered!');
            // Set the global flag to true
            window.isRechargeWidgetLoaded = true;

            // Call functions to move the badge, apply styles, and add click event
            moveBadge(widget.shadowRoot);
            applyCustomStyles(widget.shadowRoot);
            applySellingPlansStyles(widget.shadowRoot);
            {% comment %} applyRadioIconStyles(widget.shadowRoot); {% endcomment %}
            addClickCallback(widget.shadowRoot);

            // Add variant change listener
            {% comment %} addVariantChangeListener(widget.shadowRoot); {% endcomment %}

            // Update the ATC price initially
            updateATCPriceWithRecharge(widget.shadowRoot);

            // Stop the interval once the widget is detected
            clearInterval(intervalId);
          }
        }
      }, 300);
    }

    // Function to move the badge
    function moveBadge(shadowRoot) {
      const badge = shadowRoot.querySelector('.rc-purchase-option__badge');
      const target = shadowRoot.querySelector('.rc-purchase-option__subscription .rc-purchase-option__selector');

      if (badge && target) {
        target.appendChild(badge);
        console.log('Badge moved successfully!');
      }
    }

    // Function to apply custom styles
    function applyCustomStyles(shadowRoot) {
      const subscriptionWidgetStyles = `
        label.rc-purchase-option__label {
          display: flex !important;
          flex-direction: row !important;
          justify-content: space-between !important;
          align-items: flex-start !important;
          padding: 16px 21px 13px 15px!important;
        }
        .rc-purchase-option__sub-container {
          padding: 10px 16px !important;
          border-top: 1px solid rgba(181, 199, 205, 0.30);
        }
        .rc-purchase-option__badge {
          position: inherit !important;
        }
        .rc-purchase-option:not(:last-child) {
          margin-bottom: 1rem !important;
        }
        .rc-purchase-option {
          border: none !important;
          border-radius: 4px !important;
          background: #FFF !important;
        }
        .rc-purchase-option__selector {
          font-size: 16px !important;
          font-weight: 450 !important;
          line-height: 26px !important;
        }
        .rc-purchase-option__badge {
          font-size: 15px !important;
          font-weight: 600 !important;
          line-height: 26px !important;
          margin-left: 0.5rem !important;
          padding: 0.1rem 0.5rem !important;
          border-radius: 3px !important;
          background: rgba(32, 154, 202, 0.30) !important;
        }
        .rc-price {
          text-align: right !important;
          font-size: 14px !important;
          font-weight: 500 !important;
          line-height: 14px !important;
          letter-spacing: 0.5px !important;
        }
      `;

      const styleElement = document.createElement('style');
      styleElement.textContent = subscriptionWidgetStyles;
      shadowRoot.appendChild(styleElement);
      console.log('Custom styles applied successfully!');
    }

    // Function to apply styles to rc-selling-plans shadowRoot
    function applySellingPlansStyles(shadowRoot) {
      const sellingPlans = shadowRoot.querySelector('rc-selling-plans');
      if (sellingPlans && sellingPlans.shadowRoot) {
        const sellingPlansStyles = `
          .rc-plans-dropdown {
            display: flex !important;
            align-items: center !important;
            justify-content: space-between !important;
          }
          .rc-plans-dropdown .rc-plans__label + div {
            width: 70% !important;
          }
          .rc-plans__label {
            font-family: "TT Norms Pro Expanded" !important;
            font-size: 11px !important;
            font-weight: 700 !important;
            line-height: 15px !important;
            text-transform: uppercase !important;
          }
          .rc-plans-dropdown__select {
            border-radius: 2px !important;
            border: 1px solid #282828 !important;
            background: #FFF !important;

            font-family: "TT Norms Pro" !important;
            font-size: 14px !important;
            font-weight: 500 !important;
            line-height: 14px !important;
            letter-spacing: 0.5px !important;
            text-transform: capitalize !important;
          }
          @media screen and (max-width: 820px) {
            .rc-plans-dropdown{
                flex-wrap: wrap !important;
                gap: 1.2rem !important;
            }
            .rc-plans-dropdown .rc-plans__label + div{
                width: 100% !important;
            }
          }
        `;

        const styleElement = document.createElement('style');
        styleElement.textContent = sellingPlansStyles;
        sellingPlans.shadowRoot.appendChild(styleElement);
        console.log('Custom styles applied to rc-selling-plans successfully!');

        cleanSellingPlansOptions(sellingPlans.shadowRoot);
      }
      applyRadioIconStyles(shadowRoot);
    }

    function applyRadioIconStyles(shadowRoot) {
      const radioIcons = shadowRoot.querySelectorAll('rc-radio-icon'); // Select all rc-radio-icon elements
      if (radioIcons.length > 0) {
        const radioIconStyles = `
          svg.rc-checked-icon rect {
            fill: #000 !important;
          }
          svg.rc-checked-icon circle {
            fill: #FFF !important;
            r: 3 !important;
          }
        `;

        radioIcons.forEach((radioIcon) => {
          if (radioIcon.shadowRoot) {
            const styleElement = document.createElement('style');
            styleElement.textContent = radioIconStyles;
            radioIcon.shadowRoot.appendChild(styleElement);
            console.log('Custom styles applied to rc-radio-icon successfully!');
          } else {
            console.warn('rc-radio-icon does not have a shadowRoot.');
          }
        });
      } else {
        console.warn('No rc-radio-icon elements found.');
      }
    }

    // Function to clean up rc-selling-plans options
    function cleanSellingPlansOptions(shadowRoot) {
      const options = shadowRoot.querySelectorAll('[name="rc_plan"] option');

      if (!options.length) {
        return;
      }

      options.forEach((option) => {
        option.textContent = option.textContent.trim().replace(/: save \d+%/, '');
      });
    }

    // Function to add a click callback to rc-purchase-option__label
    function addClickCallback(shadowRoot) {
      const labels = shadowRoot.querySelectorAll('.rc-purchase-option__label');
      labels.forEach((label) => {
        label.addEventListener('click', function () {
          console.log('Label clicked:', label.textContent.trim());

          // Call applySellingPlansStyles after 0.5 seconds
          setTimeout(() => {
            applySellingPlansStyles(shadowRoot);
            updateATCPriceWithRecharge(shadowRoot);
          }, 100);
        });
      });
      console.log('Click event listeners added to labels!');
    }

    // Function to update the ATC price with the Recharge discounted price
    function updateATCPriceWithRecharge(shadowRoot) {
      {% comment %} console.log('Updating ATC price with Recharge discounted price...'); {% endcomment %}

      // Directly find the price element inside the selected option
      const priceElement = shadowRoot.querySelector('[rc-selected] .rc-price');

      if (priceElement) {
        // Extract only the visible price value
        const price = Array.from(priceElement.childNodes)
          .filter((node) => node.nodeType === Node.TEXT_NODE)
          .map((node) => node.textContent.trim())
          .join('');

        if (price) {
          const formattedPrice = `• ${price}`; // Append "•" before the price
          console.log('Recharge price found:', formattedPrice);

          // Update the ATC button price
          const atcPriceElement = document.querySelector('.product-form__submit--price');
          if (atcPriceElement) {
            atcPriceElement.textContent = formattedPrice;
            {% comment %} console.log('ATC button price updated with Recharge price:', formattedPrice); {% endcomment %}
          } else {
            console.warn('ATC price element not found.');
          }
        } else {
          console.warn('Price is empty after filtering visible content.');
        }
      } else {
        console.warn('Price element not found inside the selected option.');
      }
    }
{% comment %} 
    // Function to add a variant change listener
    function addVariantChangeListener(shadowRoot) {
      console.log('Adding variant change listener...');

      // Select the variant-selects element
      const variantSelects = document.querySelector('variant-selects');
      if (!variantSelects) {
        console.warn('Variant-selects element not found.');
        return;
      }

      // Add a change event listener to the variant-selects element
      variantSelects.addEventListener('change', () => {
        console.log('Variant changed. Updating ATC price...');
        setTimeout(() => {
            updateATCPriceWithRecharge(shadowRoot);
        }, 100);
      });

      console.log('Variant change listener added successfully!');
    } {% endcomment %}

    // Call the function to start monitoring
    try {
      waitForRechargeWidget();
    } catch (error) {
      console.error('Error initializing Recharge widget:', error);
    }
  });
</script>
